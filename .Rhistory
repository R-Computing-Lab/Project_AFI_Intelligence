p1 <- ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary)) +
mytheme +
#coord_trans(y="log10", limy=c(1000,6000)) +
labs(list(title = "Gen2. Within Family Spagetti Plot of \nAFI by Intelligence", y = "Gender Standardized AFI", x = "Standardized Intelligence")) +
geom_line(size=1,alpha=0.4) + theme(legend.position="right",  legend.justification=c(1, 0.5))
p1
ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary)) +
mytheme +
labs(list(title = "Gen2. Within Family Spagetti Plot of \nAFI by Intelligence", y = "Gender Standardized AFI", x = "Standardized Intelligence")) +
geom_line(size=1,alpha=0.4) + theme(legend.position="right",  legend.justification=c(1, 0.5))
mytheme <- theme_classic() %+replace%
theme(axis.title.x = element_text(face="bold",angle=0),
axis.title.y = element_text(face="bold",angle=90))
p1 <- ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary)) + scale_colour_manual(name = "Within Family \nSlope",values= c("#56B4E9", "#009E73", "#CC79A7")) +
mytheme +
labs(list(title = "Gen2. Within Family Spagetti Plot of \nAFI by Intelligence", y = "Gender Standardized AFI", x = "Standardized Intelligence")) +
geom_line(size=1,alpha=0.4) + theme(legend.position="right",  legend.justification=c(1, 0.5))
p1
ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary)) + scale_colour_manual(name = "Within Family \nSlope",values= c("#56B4E9", "#009E73", "#CC79A7"))
mytheme <- theme_classic() %+replace%
theme(axis.title.x = element_text(face="bold",angle=0),
axis.title.y = element_text(face="bold",angle=90))
p1 <- ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary)) +
mytheme + scale_colour_manual(name = "Within Family \nSlope",values= c("#56B4E9", "#009E73", "#CC79A7")) +
#coord_trans(y="log10", limy=c(1000,6000)) +
labs(list(title = "Gen2. Within Family Spagetti Plot of \nAFI by Intelligence", y = "Gender Standardized AFI", x = "Standardized Intelligence")) +
geom_line(size=1,alpha=0.4) + theme(legend.position="right",  legend.justification=c(1, 0.5))
p1
mytheme <- theme_classic() %+replace%
theme(axis.title.x = element_text(face="bold",angle=0),
axis.title.y = element_text(face="bold",angle=90))
p1 <- ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary)) +
mytheme + scale_colour_manual(name = "Within Family \nSlope",values= c("#56B4E9", "#009E73", "#CC79A7")) +
#coord_trans(y="log10", limy=c(1000,6000)) +
labs(list(title = "Gen2. Within Family Spagetti Plot of \nAFI by Intelligence", y = "Gender Standardized AFI", x = "Standardized Intelligence")) +
geom_line(size=1,alpha=0.4) + theme(legend.position="right",  legend.justification=c(1, 0.5))
p1
detach("package:gridGraphics", unload=TRUE)
detach("package:gridExtra", unload=TRUE)
p1
ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary)) +
mytheme + scale_colour_manual(name = "Within Family \nSlope",values= c("#56B4E9", "#009E73", "#CC79A7")) +
#coord_trans(y="log10", limy=c(1000,6000)) +
labs(list(title = "Gen2. Within Family Spagetti Plot of \nAFI by Intelligence", y = "Gender Standardized AFI", x = "Standardized Intelligence")) +
geom_line(size=1,alpha=0.4)
ggplot(data = Stack2, aes(x = Intel_Kid_1, y = AFI_Kid_1, group = ID, color=slopebinary))
Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))
p1 + annotate("abline",intercept=0, slope=1)
a<-Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))
length(Stack2)
nrow(Stack2)
n     <- nrow(Stack2)                    # length of vector
rho   <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] # desired correlation = cos(angle)
theta <- acos(rho)             # corresponding angle
x1    <- rnorm(n, 1, 1)        # fixed given data
x2    <- rnorm(n, 2, 0.5)      # new random data
X     <- cbind(x1, x2)         # matrix
Xctr  <- scale(X, center=TRUE, scale=FALSE)   # centered columns (mean 0)
Id   <- diag(n)                               # identity matrix
Q    <- qr.Q(qr(Xctr[ , 1, drop=FALSE]))      # QR-decomposition, just matrix Q
P    <- tcrossprod(Q)          # = Q Q'       # projection onto space defined by x1
x2o  <- (Id-P) %*% Xctr[ , 2]                 # x2ctr made orthogonal to x1ctr
Xc2  <- cbind(Xctr[ , 1], x2o)                # bind to matrix
Y    <- Xc2 %*% diag(1/sqrt(colSums(Xc2^2)))  # scale columns to length 1
x <- Y[ , 2] + (1 / tan(theta)) * Y[ , 1]     # final new vector
cor(x1, x)                                    # check correlation = rho
summary(x)
summary(x1)
sd(x1)
sd(x)
scale(x)
Mean(Stack$slope)/Sd(Stack$slope)
Sd(Stack$slope)
(Stack$Intel_Kid_2-Stack$Intel_Kid_1)
(Stack$Intel_Kid_2-Stack$Intel_Kid_1)==0
Stack$slope <- (Stack$AFI_Kid_2-Stack$AFI_Kid_1)/(Stack$Intel_Kid_2-Stack$Intel_Kid_1)
Mean(Stack$slope)
1/Mean(Stack$slope)
rnorm(15, 0, 2)
x <- (-10:10)/10
btwn <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] * x
within <- Median(Stack$slope)* x
df <- data.frame(x, btwn)
# create a copy of original data, but set y = x
# this data will be used for the one-to-one line
df2 <- data.frame(x, within)
# bind original and 'one-to-one data' together
df3 <- rbind.data.frame(df, df2)
# create a grouping variable to separate stat_smoothers based on original and one-to-one data
df3$grp <- as.factor(rep(1:2, each = nrow(df)))
# plot
# use original data for points
# use 'double data' for abline and one-to-one line, set colours by group
ggplot(df, aes(x = x, y = y)) +
geom_point(size = 3) +
stat_smooth(data = df3, aes(colour = grp), method = "lm", se = FALSE, size = 1) +
scale_colour_manual(values = c("red","blue"),
labels = c("abline", "one-to-one"),
name = "") +
theme(legend.position = "top")
df <- data.frame(x, y=btwn)
df2 <- data.frame(x, y=within)
df3 <- rbind.data.frame(df, df2)
df3$grp <- as.factor(rep(1:2, each = nrow(df)))
View(df3)
ggplot(df, aes(x = x, y = y)) +
geom_point(size = 3) +
stat_smooth(data = df3, aes(colour = grp), method = "lm", se = FALSE, size = 1) +
scale_colour_manual(values = c("red","blue"),
labels = c("abline", "one-to-one"),
name = "") +
theme(legend.position = "top")
ggplot2
library(ggplot2)
ggplot2
library(ggplot2)
ggplot(df, aes(x = x, y = y)) +
geom_point(size = 3) +
stat_smooth(data = df3, aes(colour = grp), method = "lm", se = FALSE, size = 1) +
scale_colour_manual(values = c("red","blue"),
labels = c("abline", "one-to-one"),
name = "") +
theme(legend.position = "top")
z=nrow(Stack2)
x <- (-5*z:3*z)/z
Stack2<-Stack[,c(1,2,4,6,8,11)]
### Generate within vs. between slopes
z=nrow(Stack2)/2
x <- (-5*z:3*z)/z
btwn <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] * x
within <- Median(Stack$slope)* x
df <- data.frame(x, y=btwn)
# create a copy of original data, but set y = x
# this data will be used for the one-to-one line
df2 <- data.frame(x, y=within)
# bind original and 'one-to-one data' together
df3 <- rbind.data.frame(df, df2)
# create a grouping variable to separate stat_smoothers based on original and one-to-one data
df3$grp <- as.factor(rep(1:2, each = nrow(df)))
Stack2<-data.frame(Stack2,df3)
z=nrow(Stack2)/2 +1
x <- (-5*z:3*z)/z
z=nrow(Stack2)/2 +1
x <- (-5*z:3*z)/z
btwn <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] * x
within <- Median(Stack$slope)* x
df <- data.frame(x, y=btwn)
# create a copy of original data, but set y = x
# this data will be used for the one-to-one line
df2 <- data.frame(x, y=within)
# bind original and 'one-to-one data' together
df3 <- rbind.data.frame(df, df2)
# create a grouping variable to separate stat_smoothers based on original and one-to-one data
df3$grp <- as.factor(rep(1:2, each = nrow(df)))
Stack2<-data.frame(Stack2,df3)
# plot
z=nrow(Stack2)/2 +2
x <- (-5*z:3*z)/z
btwn <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] * x
within <- Median(Stack$slope)* x
df <- data.frame(x, y=btwn)
# create a copy of original data, but set y = x
# this data will be used for the one-to-one line
df2 <- data.frame(x, y=within)
# bind original and 'one-to-one data' together
df3 <- rbind.data.frame(df, df2)
# create a grouping variable to separate stat_smoothers based on original and one-to-one data
df3$grp <- as.factor(rep(1:2, each = nrow(df)))
Stack2<-data.frame(Stack2,df3)
(-5*z:3*z)/z
z=as.numeric(nrow(Stack2)/2 +2)
x <- (-5*z:3*z)/z
-5*z
x <- (-5*z:3*z)
x<-x/z
x
x <- (-5*z:3*z)
x<-x/z
x/2
x/2[]1
x/2[1]1
x/2[1]
x/2[1,]
x/2[,1]
x*.5
x<-x*.5
1/z
z<- 1/z
x<-x*z
btwn <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] * x
within <- Median(Stack$slope)* x
df <- data.frame(x, y=btwn)
df2 <- data.frame(x, y=within)
# bind original and 'one-to-one data' together
df3 <- rbind.data.frame(df, df2)
df3$grp <- as.factor(rep(1:2, each = nrow(df)))
Stack2<-data.frame(Stack2,df3)
z=as.numeric(nrow(Stack2)/2 +2)
x <- (-5*z:3*z)
z<- 1/z
x<-x*z
btwn <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] * x
within <- Median(Stack$slope)* x
df <- data.frame(x, y=btwn)
z=as.numeric(nrow(Stack2)/2 +2)
x<-x/351
View(df3)
z=as.numeric(nrow(Stack2)/2 +2)
z=as.numeric(nrow(Stack2)/2)
-5*351
3*351
x <- (-1755:1053)/351
x <- (-349:349)
-5:3
698/2
count(-50:30)
349:count(-50:30)
349?count(-50:30)
349/count(-50:30)
349/81
x <- rep(-5:3, length=349)
698/3
x <- rep(-5:5, length=233)
btwn <- Cor(data.frame(Stack2$AFI_Kid_1,Stack2$Intel_Kid_1))[1,2] * x
within <- Mean(Stack$slope)* x
within2 <- Median(Stack$slope)* x
df <- data.frame(x, y=btwn)
# create a copy of original data, but set y = x
# this data will be used for the one-to-one line
df2 <- data.frame(x, y=within)
df22 <- data.frame(x, y=within2)
# bind original and 'one-to-one data' together
df3 <- rbind.data.frame(df, df2, df22)
# create a grouping variable to separate stat_smoothers based on original and one-to-one data
df3$grp <- as.factor(rep(1:3, each = nrow(df)))
df3[1:698]
df3[,1:698]
df3[1:698,]
is.numeric
is.numeric()
is.numeric(6)
is.numeric(a)
is.numeric("a")
is.numeric(NULL)
is.numeric(NA)
<<plot_corplotmatrix_within,fig=TRUE,echo=FALSE,cache=FALSE,fig.height=7*.6, fig.width=7,out.width="1.1\\paperwidth",warning=FALSE>>=
cor_1star <- function(x,digit=3,sig=.05,include.n=FALSE){
require(Hmisc)
x <- as.matrix(x)
R <- rcorr(x)$r
p <- rcorr(x)$P
## truncate the matrix that holds the correlations to two decimal
R <- format(round(cbind(rep(-1.11, ncol(x)), R), digit))[,-1]
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- R
if(is.numeric(sig)){
## define notions for significance levels; spacing is important.
mystars <- ifelse(p < sig, "* ", " ")
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x)) }
diag(Rnew) <- paste(diag(R), " ", sep="")
rownames(Rnew) <- colnames(x)
colnames(Rnew) <- paste(colnames(x), "", sep="")
Rnew <- as.matrix(Rnew)
if(!include.n){
## remove upper triangle
Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)-1])
}
if(include.n){
#replace upper triangle with sample size
require(psych)
ct<-corr.test(x)
ct<-as.matrix(ct$n)
Rnew[upper.tri(Rnew, diag = TRUE)] <- ct[upper.tri(ct, diag = TRUE)]
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)])#-1])
}
Rnew[Rnew=="NA"]<- ""
return(Rnew)
}
capture.output(xtable(cor_1star(matrix_g1,digit=2,sig=NA,include.n=TRUE)),file=paste0(directory,"/Common/content/tables/table_sibintreliable_z.tex"))
matrix_g1<-data.frame(dsD$Intel_G1_S1,dsD$Intel_G1_S2)
capture.output(xtable(cor_1star(matrix_g1,digit=2,sig=NA,include.n=TRUE)),file=paste0(directory,"/Common/content/tables/table_sibintreliable_z.tex"))
cor_1star(matrix_g1,digit=2,sig=NA,include.n=TRUE)
matrix_tt_z<-data.frame(dsD$AFI_83z_S1,dsD$AFI_84z_S1,dsD$AFI_85z_S1)
names(matrix_tt_z)<-c("1983","1984","1985")
cor_1star(matrix_tt_z,digit=2,sig=NA,include.n=TRUE)),file=paste0(directory,"/Common/content/tables/table_ttafireliable_z.tex"))
cor_1star(matrix_tt_z,digit=2,sig=NA,include.n=TRUE)
cor_1star <- function(x,digit=3,sig=.05,include.n=FALSE){
require(Hmisc)
x <- as.matrix(x)
R <- rcorr(x)$r
p <- rcorr(x)$P
## truncate the matrix that holds the correlations to two decimal
R <- format(round(cbind(rep(-1.11, ncol(x)), R), digit))[,-1]
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- R
if(is.numeric(sig)){
## define notions for significance levels; spacing is important.
mystars <- ifelse(p < sig, "* ", " ")
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x)) }
diag(Rnew) <- paste(diag(R), " ", sep="")
rownames(Rnew) <- colnames(x)
colnames(Rnew) <- paste(colnames(x), "", sep="")
Rnew <- as.matrix(Rnew)
if(!include.n){
## remove upper triangle
Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)-1])
}
if(include.n){
#replace upper triangle with sample size
require(psych)
ct<-corr.test(x)
ct<-as.matrix(ct$n)
Rnew[upper.tri(Rnew, diag = TRUE)] <- ct[upper.tri(ct, diag = TRUE)]
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)])#-1])
}
Rnew <- data.frame(lapply(Rnew, as.character), stringsAsFactors=FALSE)
Rnew[Rnew=="NA"]<- ""
return(Rnew)
}
cor_1star(matrix_tt_z,digit=2,sig=NA,include.n=TRUE)
cor_1star <- function(x,digit=3,sig=.05,include.n=FALSE,clean=FALSE){
require(Hmisc)
x <- as.matrix(x)
R <- rcorr(x)$r
p <- rcorr(x)$P
## truncate the matrix that holds the correlations to two decimal
R <- format(round(cbind(rep(-1.11, ncol(x)), R), digit))[,-1]
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- R
if(is.numeric(sig)){
## define notions for significance levels; spacing is important.
mystars <- ifelse(p < sig, "* ", " ")
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x)) }
diag(Rnew) <- paste(diag(R), " ", sep="")
rownames(Rnew) <- colnames(x)
colnames(Rnew) <- paste(colnames(x), "", sep="")
Rnew <- as.matrix(Rnew)
if(!include.n){
## remove upper triangle
Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)-1])
}
if(include.n){
#replace upper triangle with sample size
require(psych)
ct<-corr.test(x)
ct<-as.matrix(ct$n)
Rnew[upper.tri(Rnew, diag = TRUE)] <- ct[upper.tri(ct, diag = TRUE)]
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)])#-1])
}
if(clean){
Rnew[is.na(Rnew)] <- ""
}
return(Rnew)
}
cor_1star(matrix_tt_z,digit=2,sig=NA,include.n=TRUE,clean=TRUE)
cor_1star <- function(x,digit=3,sig=.05,include.n=FALSE,clean=FALSE){
require(Hmisc)
x <- as.matrix(x)
R <- rcorr(x)$r
p <- rcorr(x)$P
## truncate the matrix that holds the correlations to two decimal
R <- format(round(cbind(rep(-1.11, ncol(x)), R), digit))[,-1]
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- R
if(is.numeric(sig)){
## define notions for significance levels; spacing is important.
mystars <- ifelse(p < sig, "* ", " ")
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x)) }
diag(Rnew) <- paste(diag(R), " ", sep="")
rownames(Rnew) <- colnames(x)
colnames(Rnew) <- paste(colnames(x), "", sep="")
Rnew <- as.matrix(Rnew)
if(!include.n){
## remove upper triangle
Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)-1])
}
if(include.n){
#replace upper triangle with sample size
require(psych)
ct<-corr.test(x)
ct<-as.matrix(ct$n)
Rnew[upper.tri(Rnew, diag = TRUE)] <- ct[upper.tri(ct, diag = TRUE)]
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)])#-1])
}
if(clean){
Rnew[is.na(Rnew)] <- " "
}
return(Rnew)
}
cor_1star(matrix_tt_z,digit=2,sig=NA,include.n=TRUE,clean=TRUE)
cor_1star <- function(x,digit=3,sig=.05,include.n=FALSE,clean=FALSE){
require(Hmisc)
x <- as.matrix(x)
R <- rcorr(x)$r
p <- rcorr(x)$P
## truncate the matrix that holds the correlations to two decimal
R <- format(round(cbind(rep(-1.11, ncol(x)), R), digit))[,-1]
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- R
if(is.numeric(sig)){
## define notions for significance levels; spacing is important.
mystars <- ifelse(p < sig, "* ", " ")
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x)) }
diag(Rnew) <- paste(diag(R), " ", sep="")
rownames(Rnew) <- colnames(x)
colnames(Rnew) <- paste(colnames(x), "", sep="")
Rnew <- as.matrix(Rnew)
if(!include.n){
## remove upper triangle
Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)-1])
}
if(include.n){
#replace upper triangle with sample size
require(psych)
ct<-corr.test(x)
ct<-as.matrix(ct$n)
Rnew[upper.tri(Rnew, diag = TRUE)] <- ct[upper.tri(ct, diag = TRUE)]
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)])#-1])
}
if(clean){
as.matrix(Rnew[is.na(as.matrix(Rnew))]) <- ""
}
return(Rnew)
}
cor_1star(matrix_tt_z,digit=2,sig=NA,include.n=TRUE,clean=TRUE)
cor_1star <- function(x,digit=3,sig=.05,include.n=FALSE,clean=FALSE){
require(Hmisc)
x <- as.matrix(x)
R <- rcorr(x)$r
p <- rcorr(x)$P
## truncate the matrix that holds the correlations to two decimal
R <- format(round(cbind(rep(-1.11, ncol(x)), R), digit))[,-1]
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- R
if(is.numeric(sig)){
## define notions for significance levels; spacing is important.
mystars <- ifelse(p < sig, "* ", " ")
## build a new matrix that includes the correlations with their appropriate stars
Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x)) }
diag(Rnew) <- paste(diag(R), " ", sep="")
rownames(Rnew) <- colnames(x)
colnames(Rnew) <- paste(colnames(x), "", sep="")
Rnew <- as.matrix(Rnew)
if(!include.n){
## remove upper triangle
Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)-1])
}
if(include.n){
#replace upper triangle with sample size
require(psych)
ct<-corr.test(x)
ct<-as.matrix(ct$n)
Rnew[upper.tri(Rnew, diag = TRUE)] <- ct[upper.tri(ct, diag = TRUE)]
Rnew <- as.data.frame(Rnew)
Rnew <- cbind(Rnew[1:length(Rnew)])#-1])
}
if(clean){
t<-as.matrix(Rnew)
t[is.na(t)] <- ""
Rnew<-as.data.frame(t)
}
return(Rnew)
}
cor_1star(matrix_tt_z,digit=2,sig=NA,include.n=TRUE,clean=TRUE)
View(Gen1AFI_exportconcor)
z<-data.frame(Gen1AFI_exportconcor,testretest$SEX)
summary(z[z$testretest.SEX=="Female"])
z[z$testretest.SEX=="Female"]
\input{../Common/content/writing/intelligence.tex}
z$testretest.SEX=="Female"
a<-z[z$testretest.SEX=="Female"]
z[z$testretest.SEX=="Female"]<-NULL
z$AFI_G1[z$testretest.SEX=="Female"]
Mean(z$AFI_G1[z$testretest.SEX=="Female"])
SD(z$AFI_G1[z$testretest.SEX=="Female"])
Sd(z$AFI_G1[z$testretest.SEX=="Female"])
length(z$AFI_G1[z$testretest.SEX=="Female"])
length(!is.na(z$AFI_G1[z$testretest.SEX=="Female"]))
summary(z$AFI_G1[z$testretest.SEX=="Female"])
count(z$AFI_G1[z$testretest.SEX=="Female"])
a<-(z$AFI_G1[z$testretest.SEX=="Female"])
6283-721
Mean(z$AFI_G1[z$testretest.SEX=="Male"])
Sd(z$AFI_G1[z$testretest.SEX=="Male"])
a<-(z$AFI_G1[z$testretest.SEX=="Male"])
summary(a)
6402-762
!is.na(sig)
sig=NA
!is.na(sig)
